/** This file is part of Wakanda software, licensed by 4D under*  (i) the GNU General Public License version 3 (GNU GPL v3), or*  (ii) the Affero General Public License version 3 (AGPL v3) or*  (iii) a commercial license.* This file remains the exclusive property of 4D and/or its licensors* and is protected by national and international legislations.* In any event, Licensee's compliance with the terms and conditions* of the applicable license constitutes a prerequisite to any use of this file.* Except as otherwise expressly stated in the applicable license,* such license does not include any other license or rights on this file,* 4D's and/or its licensors' trademarks and/or other proprietary rights.* Consequently, no title, copyright or other proprietary rights* other than those specified in the applicable license is granted.*//** * @author admin *///exports.Log = function Log(file) {// Constructor function definition		var log;		log = {		appendToLog : function(myMessage) {// append function			var file,				stream;						file = this.logFile;						if(file != null) {				if(!file.exists) {// if the file does not exist					file.create();				}				// create it				stream = TextStream(file, "write");				// open the stream in write mode				stream.write(myMessage + "\n");				// append the message to the end of stream				stream.close();				// do not forget to close the stream			}		},		init : function(file) {// to initialize the log					this.logFile = file;			if(file.exists) {				file.remove();			}			file.create();		},		set : function(file) {// to create the log file					if( typeof file == "string") {// only text files can be created				file = File(file);			}			this.logFile = file;		},		logFile : null	}	log.set(file);	return log;}/** * file : { * 	name : file_name * 	app_name : application_name * 	sol_name : solution_name * }
 */exports.Readfile = function read_file(file) {	var str,		app,		sol,		stream,		recentOpened,		newSolutionOpen;		sol = null;		try {		if(file.sol_name !== solution.name) {						recentOpened = internal.recentlyOpenedSolution();			// return internal.recentlyOpenedSolution();			i = 0;						while(sol === null && i < recentOpened.length) {						solTmp = recentOpened[i];				if(solTmp.name === file.sol_name) {										sol = solTmp;					sol = internal.openSolution(sol.solutionFile.path, 2);					newSolutionOpen = true;				}								i++;			}					} else {			sol = solution;			newSolutionOpen = false;		}				if(sol !== null) {			app = sol.getApplicationByName(file.app_name);						file = File(app.ds.getDataFolder().path + 'Logs/' + file.name);			stream = TextStream(file, "read");			str = stream.read();		}
			} catch(e) {		console.log("Error on read file " + file.name, e);		return e;	} finally {				if(newSolutionOpen && sol !== null) {			sol.close();			sol = null;		}	}	return str;}exports.ReadFileByPath = function read_file_by_path(filePath) {		var str,		file,		stream;		try {		if(File.isFile(filePath)) {			file = File(filePath);			stream = TextStream(file, "read");			str = stream.read();		}			} catch(e) {		console.log("Error on read file " + filePath, e);	}	return str;}exports.DeleteFile = function delete_file(file) {		var pos,		sol,		reg,		tab,		app,		delFile,		datapath,		recentOpened,		recentSolution		if(file.sol_name != solution.name) {		recentOpened = internal.recentlyOpenedSolution();		recentSolution = null;		for(pos = 0; pos < recentOpened.length; pos++) {			if((recentSolution == null) && (recentOpened[pos].name == file.sol_name)) {				recentSolution = recentOpened[pos];			}		}		if((recentSolution != null) && ( typeof recentSolution != 'undefined')) {			try {				sol = internal.openSolution(recentSolution.solutionFile.path, 2);								if((sol != null) && ( typeof sol != 'undefined')) {										reg = new RegExp("[ ]+", "g");					tab = file.name.split(reg);					app = sol.getApplicationByName(tab[1]);										if((app.getItemsWithRole("data") == null) || ( typeof app.getItemsWithRole("data") == 'undefined')) {						return 'Not Done';					}										datapath = app.getItemsWithRole("data").path;					datapath = datapath.replace(app.getItemsWithRole("data").name, "");					delFile = File(datapath + 'Logs/' + file.name);					delFile.remove();					return 'Done';				}			} catch (e) {			} finally {								if((sol != null) && ( typeof sol != 'undefined')) {					sol.close();					sol = null;				}			}		}	} else {		reg = new RegExp("[ ]+", "g");		tab = file.name.split(reg);		app = solution.getApplicationByName(tab[1]);				if((app.getItemsWithRole("data") == null) || ( typeof app.getItemsWithRole("data") == 'undefined')) {			return 'Not Done';		}		datapath = app.getItemsWithRole("data").path;		datapath = datapath.replace(app.getItemsWithRole("data").name, "");		delFile = File(datapath + 'Logs/' + file.name);		delFile.remove();				return 'Done';	}}exports.Files = function files(application) {	var pos,		sol,		app,		obj,		datapath,		folderlog,		application,		recentOpened,		recentSolution,		newSolutionOpen;		sol = null;		if(application.sol_name !== solution.name) {				recentOpened = internal.recentlyOpenedSolution();		i = 0;				while(sol === null && i < recentOpened.length) {				solTmp = recentOpened[i];			if(solTmp.name === application.sol_name) {								sol = solTmp;				sol = internal.openSolution(sol.solutionFile.path, 2);				newSolutionOpen = true;			}						i++;		}			} else {		sol = solution;		newSolutionOpen = false;	}	try {		if((sol != null) && ( typeof sol != 'undefined')) {			app = sol.getApplicationByName(application.name);			if((app.getItemsWithRole("data") == null) || ( typeof app.getItemsWithRole("data") == 'undefined')) {				obj = {};				obj.files = [];			} else {				datapath = app.getItemsWithRole("data").path;				datapath = datapath.replace(app.getItemsWithRole("data").name, "");					folderlog = Folder(datapath + 'Logs');					obj = {};				obj.files = {					"verify" : [],					"repair" : [],					"compact" : [],					"unknow" : []				};				folderlog.forEachFile(function(file) {										var fileObject;						fileObject = {};					fileObject.name = file.name;					fileObject.date = file.creationDate;					fileObject.path = file.path;										if(file.name.substr(0, 6) === "verify") {												obj.files.verify.push(fileObject);					} else if(file.name.substr(0, 6) === "repair") {												obj.files.repair.push(fileObject);					} else if(file.name.substr(0, 7) === "compact") {												obj.files.compact.push(fileObject);					} else {												obj.files.unknow.push(fileObject);					}								});			}					}	} catch (e) {	} finally {		if((sol !== null) && ( typeof sol !== 'undefined') && newSolutionOpen) {			sol.close();			sol = null;		}	}		return obj;}//Repair Functionexports.Repair = function repair(application) {		var i,		app,		log,		res,		sol,		date,		item,		solTmp,		result,		logname,		folderM,		options,		datapath,		folderlog,		modelData,		modelFile,		repairDest,		recentSols,		currentdate,		modeleIndexFile,		modeleMatchFile,		modeleIndexRepairedFile,		modeleMatchRepairedFile;	function myOpenProgress(title, maxElements) {		log.appendToLog(title + " on " + maxElements + " elements");		console.info(title + " on " + maxElements + " elements");		// this.storedProblems.push(title + " on " + maxElements + " elements");		// log the progress events	}	function myProgress(curElement, maxElements) {		console.info(curElement + "/" + maxElements + " - "+ parseInt((curElement/maxElements)*100, 10) + " %");	}	function myCloseProgress() {		// add code to handle the closing of the progress event	}	function myAddProblem(problem) {		this.storedProblems.push(problem);		// fill the custom array		log.appendToLog(problem.ErrorText);	}	recentSols = internal.recentlyOpenedSolution();	result = {};	/**	 * solutions : contains all the recent solutions	 */	result.solutions = [];		sol = null;	i = 0;		while(sol === null && i < recentSols.length) {		solTmp = recentSols[i];		if(solTmp.name === application.sol_name) {						if(solution.name === solTmp.name) {								sol = solution;			} else {								sol = solTmp;				sol = internal.openSolution(sol.solutionFile.path, 2);			}		}				i++;	}	item = {};	item.name = sol.name;	item.projects = [];	try {		if((sol != null) && ( typeof sol != 'undefined')) {			app = sol.getApplicationByName(application.name);			if((app.getItemsWithRole("data") == null) || ( typeof app.getItemsWithRole("data") == 'undefined')) {				options = {					'storedProblems' : []				}				return options.storedProblems;			}			modelFile = File(app.getItemsWithRole("catalog").path);						modelData = File(app.getItemsWithRole("data").path);						datapath = app.getItemsWithRole("data").path;			datapath = datapath.replace(app.getItemsWithRole("data").name, "");			folderlog = Folder(datapath + 'Logs');			if(!folderlog.exists) {//check for subfolder named Documents				try {					folderlog.create();					//if not there, create it				} catch (e) {//if you can't create it, then error out					return {						error : 5,						errorMessage : ' could not create doc folder'					};				}			}						date = new Date();			currentdate = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + 'T' + date.getHours() + '.' + date.getMinutes() + '.' + date.getSeconds();						folderM = Folder(datapath + 'Replaced files (repairing) ' + currentdate);			if(!folderM.exists) {//check for subfolder named Documents				try {					folderM.create();					//if not there, create it				} catch (e) {//if you can't create it, then error out					return {						error : 5,						errorMessage : ' could not create doc folder'					};				}			}						logname = 'repair ' + app.name + ' ' + currentdate + '.waLog';			log = new Log(datapath + 'Logs/' + logname);						repairDest = File(datapath + 'Replaced files (repairing) ' + currentdate +'/repaired_' + app.name + '.waData');			options = {				'openProgress' : myOpenProgress,				'closeProgress' : myCloseProgress,				'progress' : myProgress,				'addProblem' : myAddProblem,				// you can add any custom code here, it will be passed to the				// addProblem function in the 'this' keyword				'storedProblems' : [] // we add an array to store any problems that arise			}						app.repairDataStore(modelFile, modelData, options, repairDest);						if(options.storedProblems.length > 0) {				log.appendToLog(options.storedProblems.length + " errors found");								res = {					errors : options.storedProblems,					file : {						name : log.logFile.name,						date : log.logFile.creationDate,						path : log.logFile.path					}				};							} else {				log.appendToLog("no errors found");								//Replace Data file				modelData.copyTo(datapath + 'Replaced files (repairing) ' + currentdate +'/' + app.name + '.waData');				repairDest.moveTo(modelData, true);								//Replace Index File				if(File.isFile(datapath + app.name + '.waIndx')) {					modeleIndexFile = File(datapath + app.name + '.waIndx');					modeleIndexFile.copyTo(datapath + 'Replaced files (repairing) ' + currentdate +'/' + app.name + '.waIndx', true);										modeleIndexRepairedFile = File(datapath + 'Replaced files (repairing) ' + currentdate +'/repaired_' + app.name + '.waIndx');					modeleIndexRepairedFile.moveTo(modeleIndexFile, true);				}				//Replace Match File				if(File.isFile(datapath + app.name + '.Match')) {					modeleMatchFile = File(datapath + app.name + '.Match');					modeleMatchFile.copyTo(datapath + 'Replaced files (repairing) ' + currentdate +'/' + app.name + '.Match', true);										modeleMatchRepairedFile = File(datapath + 'Replaced files (repairing) ' + currentdate +'/repaired_' + app.name + '.Match');					modeleMatchRepairedFile.moveTo(modeleMatchFile, true);				}								res = {					errors : options.storedProblems,					file : {						name : log.logFile.name,						date : log.logFile.creationDate,						path : log.logFile.path					}				};							}		}	} catch(e) {		console.log(e)	} finally {		try {						if(solution.name != sol.name) {				sol.close();			}		} catch(e) {		}	}		return res;}// Compact Functionexports.Compact = function compact(application) {		var i,		app,		log,		res,		sol,		date,		item,		solTmp,		result,		folderM,		logname,		options,		datapath,		folderlog,		modelFile,		modelData,		recentSols,		currentdate,		compactDest,		modeleIndexFile,		modeleMatchFile,		modeleIndexCompactedFile,		modeleMatchCompactedFile;		function myOpenProgress(title, maxElements) {		log.appendToLog(title + " on " + maxElements + " elements");		console.info(title + " on " + maxElements + " elements");		// log the progress events	}	function myProgress(curElement, maxElements) {		console.info(curElement + "/" + maxElements + " - "+ parseInt((curElement/maxElements)*100, 10) + " %");	}	function myCloseProgress() {		// add code to handle the closing of the progress event	}	function myAddProblem(problem) {		this.storedProblems.push(problem);		// fill the custom array		log.appendToLog(problem.ErrorText);	}	recentSols = internal.recentlyOpenedSolution();	result = {};	/**	 * solutions : contains all the recent solutions	 */	result.solutions = [];	sol = null;	i = 0;		while(sol === null && i < recentSols.length) {		solTmp = recentSols[i];		if(solTmp.name === application.sol_name) {						if(solution.name === solTmp.name) {								sol = solution;			} else {								sol = solTmp;				sol = internal.openSolution(sol.solutionFile.path, 2);			}		}				i++;	}			item = {};	item.name = sol.name;	item.projects = [];	try {		if((sol != null) && ( typeof sol != 'undefined')) {			app = sol.getApplicationByName(application.name);			if((app.getItemsWithRole("data") == null) || ( typeof app.getItemsWithRole("data") == 'undefined')) {				options = {					'storedProblems' : []				}				return options.storedProblems;			}						modelFile = File(app.getItemsWithRole("catalog").path);						modelData = File(app.getItemsWithRole("data").path);			datapath = app.getItemsWithRole("data").path;			datapath = datapath.replace(app.getItemsWithRole("data").name, "");			folderlog = Folder(datapath + 'Logs');			if(!folderlog.exists) {//check for subfolder named Documents				try {					folderlog.create();					//if not there, create it				} catch (e) {//if you can't create it, then error out					return {						error : 5,						errorMessage : ' could not create doc folder'					};				}			}						date = new Date();			currentdate = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + 'T' + date.getHours() + '.' + date.getMinutes() + '.' + date.getSeconds();						folderM = Folder(datapath + 'Replaced files (compacting) ' + currentdate);			if(!folderM.exists) {//check for subfolder named Documents				try {					folderM.create();					//if not there, create it				} catch (e) {//if you can't create it, then error out					return {						error : 5,						errorMessage : ' could not create doc folder'					};				}			}			logname = 'compact ' + app.name + ' ' + currentdate + '.waLog';			log = new Log(datapath + 'Logs/' + logname);			compactDest = File(datapath + 'Replaced files (compacting) ' + currentdate + '/compacted_' + app.name + '.waData');						options = {				'openProgress' : myOpenProgress,				'closeProgress' : myCloseProgress,				'progress' : myProgress,				'addProblem' : myAddProblem,				// you can add any custom code here, it will be passed to the				// addProblem function in the 'this' keyword				'storedProblems' : [] // we add an array to store any problems that arise			}			app.compactDataStore(modelFile, modelData, options, compactDest);			if(options.storedProblems.length > 0) {				log.appendToLog(options.storedProblems.length + " errors found");								res = {					errors : options.storedProblems,					file : {						name : log.logFile.name,						date : log.logFile.creationDate,						path : log.logFile.path					}				};			} else {				log.appendToLog("no errors found");								//Replace Data file				modelData.copyTo(datapath + 'Replaced files (compacting) ' + currentdate + '/' + app.name + '.waData', true);				compactDest.moveTo(modelData, true);								//Replace Index File				if(File.isFile(datapath + app.name + '.waIndx')) {					modeleIndexFile = File(datapath + app.name + '.waIndx');					modeleIndexFile.copyTo(datapath + 'Replaced files (compacting) ' + currentdate + '/' + app.name + '.waIndx', true);										modeleIndexCompactedFile = File(datapath + 'Replaced files (compacting) ' + currentdate + '/compacted_' + app.name + '.waIndx');					modeleIndexCompactedFile.moveTo(modeleIndexFile, true);				}								//Replace Match File				if(File.isFile(datapath + app.name + '.Match')) {					modeleMatchFile = File(datapath + app.name + '.Match');					modeleMatchFile.copyTo(datapath + 'Replaced files (compacting) ' + currentdate + '/' + app.name + '.Match', true);										modeleMatchCompactedFile = File(datapath + 'Replaced files (compacting) ' + currentdate + '/compacted_' + app.name + '.Match');					modeleMatchCompactedFile.moveTo(modeleMatchFile, true);				}								res = {					errors : options.storedProblems,					file : {						name : log.logFile.name,						date : log.logFile.creationDate,						path : log.logFile.path					}				};			}		}	} catch(e) {		console.log(e)	} finally {		try {			if(solution.name != sol.name) {				sol.close();			}		} catch(e) {		}	}					return res;}// Verify functionexports.Verify = function verify(application) {		var i,		app,		log,		res,		sol,		date,		item,		result,		solTmp,		logname,		options,		datapath,		folderlog,		modelData,		modelFile,		recentSols,		currentdate;		function myOpenProgress(title, maxElements) {		log.appendToLog(title + " on " + maxElements + " elements");		console.info(title + " on " + maxElements + " elements");		// log the progress events	}	function myProgress(curElement, maxElements) {		console.info(curElement + "/" + maxElements + " - "+ parseInt((curElement/maxElements)*100, 10) + " %");	}	function myCloseProgress() {		// add code to handle the closing of the progress event	}	function myAddProblem(problem) {		this.storedProblems.push(problem);		// fill the custom array		log.appendToLog(problem.ErrorText);	}	recentSols = internal.recentlyOpenedSolution();	result = {};	/**	 * solutions : contains all the recent solutions	 */	result.solutions = [];	sol = null;	i = 0;		while(sol === null && i < recentSols.length) {		solTmp = recentSols[i];		if(solTmp.name === application.sol_name) {						if(solution.name === solTmp.name) {								sol = solution;			} else {								sol = solTmp;				sol = internal.openSolution(sol.solutionFile.path, 2);			}		}				i++;	}		item = {};	item.name = sol.name;	item.projects = [];	try {		if((sol != null) && ( typeof sol != 'undefined')) {			app = sol.getApplicationByName(application.name);			if((app.getItemsWithRole("data") == null) || ( typeof app.getItemsWithRole("data") == 'undefined')) {				options = {					'storedProblems' : []				}				return options.storedProblems;			}						modelFile = File(app.getItemsWithRole("catalog").path);						modelData = File(app.getItemsWithRole("data").path);			datapath = app.getItemsWithRole("data").path;			datapath = datapath.replace(app.getItemsWithRole("data").name, "");			folderlog = Folder(datapath + 'Logs');			if(!folderlog.exists) {//check for subfolder named Documents				try {					folderlog.create();					//if not there, create it				} catch (e) {//if you can't create it, then error out					return {						error : 5,						errorMessage : ' could not create doc folder'					};				}				}			date = new Date();			currentdate = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + 'T' + date.getHours() + '.' + date.getMinutes() + '.' + date.getSeconds();			logname = 'verify ' + app.name + ' ' + currentdate + '.waLog';			log = new Log(datapath + 'Logs/' + logname);			options = {				'openProgress' : myOpenProgress,				'closeProgress' : myCloseProgress,				'progress' : myProgress,				'addProblem' : myAddProblem,				// you can add any custom code here, it will be passed to the				// addProblem function in the 'this' keyword				'storedProblems' : [] // we add an array to store any problems that arise			}			app.verifyDataStore(modelFile, modelData, options);			if(options.storedProblems.length > 0) {				log.appendToLog(options.storedProblems.length + " errors found");				res = {					errors : options.storedProblems,					file : {						name : log.logFile.name,						date : log.logFile.creationDate,						path : log.logFile.path					}				};				return res;			} else {				log.appendToLog("no errors found");				res = {					errors : options.storedProblems,					file : {						name : log.logFile.name,						date : log.logFile.creationDate,						path : log.logFile.path					}				};				return res;			}		}	} catch(e) {		console.log(e);	} finally {		try {			if(solution.name != sol.name) {				sol.close();			}		} catch(e) {		}	}}exports.setService = function set_service(applicationName, serviceName, enable) {	var service,		application;		application = solution.getApplicationByName(applicationName);	service = application[serviceName]; (enable) ? service.enable() : service.disable();	return service.enabled;}exports.setServer = function set_server(applicationName, serverName, start) {	var server,		application;		application = solution.getApplicationByName(applicationName);	server = application[serverName];	(start) ? server.start() : server.stop();	return server.started;}exports.stopRPCForApp = function stop_rpc_for_app(appName) {	var app,		rpcService;		app = solution.getApplicationByName(appName);	rpcService = require("services/rpc").getInstanceFor(app);	if((rpcService != null) && ( typeof rpcService != 'undefined')) {		rpcService.stop();		return !rpcService.isStarted();	}	return false;}exports.startRPCForApp = function start_rpc_for_app(appName) {	var app,		rpcService;		app = solution.getApplicationByName(appName);	rpcService = require("services/rpc").getInstanceFor(app);	if((rpcService != null) && ( typeof rpcService != 'undefined')) {		rpcService.start();		return rpcService.isStarted();	}	return false;}exports.stopDataServiceForApp = function stop_data_service_for_app(appName) {	var app,		dataStoreService;		app = solution.getApplicationByName(appName);	dataStoreService = require("services/dataStore").getInstanceFor(app);	if((dataStoreService != null) && ( typeof dataStoreService != 'undefined')) {		dataStoreService.stop();		return !dataStoreService.isStarted();	}	return false;}exports.startDataServiceForApp = function start_data_service_for_app(appName) {	var app,		dataStoreService;		app = solution.getApplicationByName(appName);	dataStoreService = require("services/dataStore").getInstanceFor(app);	if((dataStoreService != null) && ( typeof dataStoreService != 'undefined')) {		dataStoreService.start();		return dataStoreService.isStarted();	}	return false;}exports.stopFileServiceForApp = function stop_file_service_for_app(appName) {	var app;		app = solution.getApplicationByName(appName);	return true;}exports.startFileServiceForApp = function start_file_service_for_app(appName) {	var app;		app = solution.getApplicationByName(appName);	return true;}exports.stopWebAppForApp = function stop_web_app_for_app(appName) {	var app,		webAppService;		app = solution.getApplicationByName(appName);	webAppService = require("services/webApp").getInstanceFor(app);	if((webAppService != null) && ( typeof webAppService != 'undefined')) {		webAppService.stop();		return !webAppService.isStarted();	}	return false;}exports.startWebAppForApp = function start_web_app_for_app(appName) {	var app,		webAppService;		app = solution.getApplicationByName(appName);	webAppService = require("services/webApp").getInstanceFor(app);	if((webAppService != null) && ( typeof webAppService != 'undefined')) {		webAppService.start();		return webAppService.isStarted();	}	return false;}exports.stopHTTPServerForApp = function stop_HTTP_server_for_app(appName) {	var app;		app = solution.getApplicationByName(appName);	if(app.httpServer.started) {		app.httpServer.stop();	}	return true;	//return !app.httpServer.started;}exports.startHTTPServerForApp = function start_HTTP_server_for_app(appName) {	var app;		app = solution.getApplicationByName(appName);	if(!app.httpServer.started) {		app.httpServer.start();	}	return app.httpServer.started;}exports.stopSqlServerForApp = function stop_sql_server_for_app(appName) {	var app;		app = solution.getApplicationByName(appName);	if(app.sqlServer.started) {		app.sqlServer.stop();	}	return !app.sqlServer.started;}exports.startSqlServerForApp = function start_sql_server_for_app(appName) {	var app;		app = solution.getApplicationByName(appName);	if(!app.sqlServer.started) {		app.sqlServer.start();	}	return app.sqlServer.started;}exports.getSettingsFilesForApp = function get_settings_files_for_app(appName) {	var i,		j,		app,		res,		file,		files,		types,		found;		types = ['project', 'http', 'webApp', 'dataService', 'rpc', 'database'];	app = solution.getApplicationByName(appName);	res = {};	files = [];		for(i = 0; i < types.length; i++) {				file = app.getSettingFile(types[i], 'relativePath');		res[types[i]] = {			'file' : file		};				j = 0;		found = false;				while(!found && j < files.length) {			if(file === files[j]) {				found = true;			}			j++;		}				if(!found && file != null) {			files.push(file);		}	}	res.files = files;	return res;}exports.getSolution = function get_solution() {	var i,		app,		obj,		datapath,		folderlog,		rpcService,		webAppService,		dataStoreService;		obj = {};	obj.name = solution.name;	obj.path = solution.getFolder('path');	obj.applications = [];	for(i = 0; i < solution.applications.length; i++) {				app = {};		app.name = solution.applications[i].name;		app.path = solution.applications[i].getFolder('path');		app.admin = solution.applications[i].administrator;		app.pattern = solution.applications[i].pattern;		if((solution.applications[i].getItemsWithRole("catalog") != null) && ( typeof solution.applications[i].getItemsWithRole("catalog") != 'undefined')) {						app.waModel = solution.applications[i].getItemsWithRole("catalog").path;		} else {			app.waModel = "";			app.waModelshort = "";		}				if((solution.applications[i].getItemsWithRole("data") != null) && ( typeof solution.applications[i].getItemsWithRole("data") != 'undefined')) {						app.waData = solution.applications[i].getItemsWithRole("data").path;			datapath = app.waData;			datapath = datapath.replace(solution.applications[i].getItemsWithRole("data").name, "");			app.files = [];			folderlog = Folder(datapath + 'Logs');			folderlog.forEachFile(function(file) {				var f;				f = {};				f.name = file.name				f.date = file.creationDate				f.path = file.path				app.files.push(f);				// store the file path			});		} else {						app.waData = "";			app.waDatashort = "";			app.files = [];		}		app.http = {			enabled : solution.applications[i].httpServer.started,			ip : solution.applications[i].httpServer.ipAddress,			port : solution.applications[i].httpServer.port,			hostName : solution.applications[i].httpServer.hostName		};		app.webApp = {			enabled : false,			directoryIndex : ''		};				webAppService = require('services/webApp').getInstanceFor(solution.applications[i]);				if((webAppService != null) && ( typeof webAppService != 'undefined')) {						app.webApp.enabled = webAppService.isStarted();			app.webApp.directoryIndex = solution.applications[i].settings.getItem('services')['webApp'].directoryIndex;		}				app.dataService = {			enabled : false		};				dataStoreService = require('services/dataStore').getInstanceFor(solution.applications[i]);				if((dataStoreService != null) && ( typeof dataStoreService != 'undefined')) {						app.dataService.enabled = dataStoreService.isStarted();		}		app.rpcService = {			enabled : false		};				rpcService = require('services/rpc').getInstanceFor(solution.applications[i]);				if((rpcService != null) && ( typeof rpcService != 'undefined')) {			app.rpcService.enabled = rpcService.isStarted();		}				app.fileService = {			enabled : false		};		obj.applications.push(app);	}	return obj;}exports.getSolutionmaintenance = function get_solutionmaintenance(name) {		var i,		pos,		sol,		obj,		app,		datapath,		folderlog,		rpcService,		application,		recentOpened,		webAppService,		recentSolution,		dataStoreService;		try {				recentOpened = internal.recentlyOpenedSolution();			recentSolution = null;		pos = 0;		while(recentSolution === null && pos < recentOpened.length) {				if(recentOpened[pos].name === name) {				recentSolution = recentOpened[pos];			}			pos++;		}			obj = {};				if(recentSolution !== null) {			sol = internal.openSolution(recentSolution.solutionFile.path, 2);						if((sol !== null) && ( typeof sol !== 'undefined')) {					obj.name = sol.name;				obj.path = sol.getFolder('path');				obj.applications = [];				obj.settings = getSettingsFromSoltion(sol);					for(i = 0; i < sol.applications.length; i++) {										application = sol.applications[i];										app = {};					app.name = application.name;					app.path = application.getFolder('path');					app.admin = application.administrator;					app.pattern = application.pattern;										if((application.getItemsWithRole("catalog") != null) && ( typeof application.getItemsWithRole("catalog") != 'undefined')) {												app.waModel = application.getItemsWithRole("catalog").path;						} else {							app.waModel = "";						app.waModelshort = "";						}										if((application.getItemsWithRole("data") != null) && ( typeof application.getItemsWithRole("data") != 'undefined')) {												app.waData = application.getItemsWithRole("data").path;							datapath = app.waData;						datapath = datapath.replace(application.getItemsWithRole("data").name, "");							app.files = [];							folderlog = Folder(datapath + 'Logs');							folderlog.forEachFile(function(file) {							var f;								f = {};							f.name = file.name							f.date = file.creationDate							f.path = file.path							app.files.push(f);							// store the file path						});											} else {							app.waData = "";						app.waDatashort = "";						app.files = [];					}						app.http = {						enabled : application.httpServer.started,						ip : application.httpServer.ipAddress,						port : application.httpServer.port,						hostName : application.httpServer.hostName					};						app.webApp = {						enabled : false,						directoryIndex : ''					};										webAppService = require('services/webApp').getInstanceFor(application);										if((webAppService != null) && ( typeof webAppService != 'undefined')) {												app.webApp.enabled = webAppService.isStarted();						app.webApp.directoryIndex = application.settings.getItem( 'services')['webApp'].directoryIndex;					}						app.dataService = {						enabled : false					};										dataStoreService = require('services/dataStore').getInstanceFor(application);										if((dataStoreService != null) && ( typeof dataStoreService != 'undefined')) {												app.dataService.enabled = dataStoreService.isStarted();					}						app.rpcService = {						enabled : false					};										rpcService = require('services/rpc').getInstanceFor(application);										if((rpcService != null) && ( typeof rpcService != 'undefined')) {												app.rpcService.enabled = rpcService.isStarted();					}										app.fileService = {						enabled : false					};						obj.applications.push(app);				}			} else {				sol = null;			}		}	} catch (e) {				sol = null;			} finally {				if(sol !== null) {			sol.close();			sol = null;		}	}		return obj;}exports.getRecentSolutions = function get_recent_solutions() {		var i,		res,		solutions;		res = internal.recentlyOpenedSolution();	solutions = []	for(i = 0; i < res.length; i++) {		solutions.push(res[i].name);	}	return solutions;}exports.openSolution = function open_solution(path) {	try {		internal.openSolution(path, 1);		return true;			} catch(e) {				return false;	}}exports.openRecentSolution = function open_recent_solution(name) {		try {		solution.openRecent(name);		return true;	} catch(e) {		return false;	}}exports.closeSolution = function close_solution() {	solution.close();	return true;}exports.getLogMessages = function get_log_messages() {	var log;		log = {};	log.messages = console.content;		log.messages.forEach(function (element, index, messageArray) {				messageArray[index] = element.replace(", HTTP connection handler", "");	});	return log;}exports.quitServer = function quit_server() {	solution.quitServer();	return true;}exports.getDebuggerPort = function get_debugger_port() {	if(solution !== null) {		return solution.getDebuggerPort();	}		return null;}exports.getSolutions = function get_solutions() {		var i,		j,		app,		sol,		item,		result,		project,		datapath,		folderlog,		rpcService,		recentSols,		webAppService,		dataStoreService;	recentSols = internal.recentlyOpenedSolution();	result = {};	/**	 * solutions : contains all the recent solutions	 */	result.solutions = [];	for(i = 0; i < recentSols.length; i++) {		sol = recentSols[i];		item = {};		item.name = sol.name;		// projects : contains all the recent projects		item.projects = [];		try {			if(solution.name === sol.name) {				sol = solution;			} else {				sol = internal.openSolution(sol.solutionFile.path, 2);			}			if((sol != null) && ( typeof sol != 'undefined')) {								for(j = 0; j < sol.applications.length; j++) {										project = sol.applications[j]					app = {};					app.name = project.name;					app.path = project.getFolder('path');					app.admin = project.administrator;					app.pattern = project.pattern;					//					if((project.getItemsWithRole("catalog") != null) && ( typeof project.getItemsWithRole("catalog") != 'undefined')) {												app.waModel = project.getItemsWithRole("catalog").path;						app.waModelshort = "";					} else {						app.waModel = "";						app.waModelshort = "";					}										if((project.getItemsWithRole("data") != null) && ( typeof project.getItemsWithRole("data") != 'undefined')) {												app.waData = project.getItemsWithRole("data").path;						app.waDatashort = "";						datapath = app.waData;						datapath = datapath.replace(project.getItemsWithRole("data").name, "");						app.logFiles = [];						folderlog = Folder(datapath + 'Logs');						folderlog.forEachFile(function(file) {							var f;							f = {};							f.name = file.name							f.date = file.creationDate							f.path = file.path							app.logFiles.push(f);							// store the file path						});											} else {						app.waData = "";						app.waDatashort = "";						app.logFiles = [];					}										app.http = {						enabled : project.httpServer.started,						ip : project.httpServer.ipAddress,						port : project.httpServer.port,						hostName : project.httpServer.hostName					};					app.webApp = {						enabled : false,						directoryIndex : ''					};										webAppService = require('services/webApp').getInstanceFor(project);										if((webAppService != null) && ( typeof webAppService != 'undefined')) {												app.webApp.enabled = webAppService.isStarted();						app.webApp.directoryIndex = project.settings.getItem( 'services')['webApp'].directoryIndex;					}										app.dataService = {						enabled : false					};										dataStoreService = require('services/dataStore').getInstanceFor(project);										if((dataStoreService != null) && ( typeof dataStoreService != 'undefined')) {												app.dataService.enabled = dataStoreService.isStarted();					}										app.rpcService = {						enabled : false					};										rpcService = require('services/rpc').getInstanceFor(project);										if((rpcService != null) && ( typeof rpcService != 'undefined')) {												app.rpcService.enabled = rpcService.isStarted();					}										app.fileService = {						enabled : false					};					if(app.admin != true) {						item.projects.push(app);					}				}			}		} catch(e) {			console.log(e)		} finally {			try {				if(solution.name != sol.name) {					sol.close();				}			} catch(e) {			}		}		result.solutions.push(item);	}	return result;}exports.getRecentSolutionsList = function get_recent_solutions_list() {			return internal.recentlyOpenedSolution();}exports.getSettingsFileForSolution = function get_settings_file_for_solution(solutionName) {			var sol,		pos,		settingsObject,		reopenSolution;		if(solution.name === solutionName) {		reopenSolution = false;		sol = solution;	} else {		reopenSolution = true;				recentOpened = internal.recentlyOpenedSolution();			recentSolution = null;		pos = 0;				while(recentSolution === null && pos < recentOpened.length) {						if(recentSolution === null && recentOpened[pos].name === solutionName) {				recentSolution = recentOpened[pos];			}						pos++;		}				if(recentSolution !== null) {						try {
								sol = internal.openSolution(recentSolution.solutionFile.path, 2);			} catch(e) {								console.log("Error : ", e);				if(reopenSolution) {					sol.close();				}				return false;			}		} else {			console.log("Error : Solution not found", recentOpened);			return false;		}			}			settingsObject = getSettingsFromSoltion(sol);		if(reopenSolution) {		sol.close();	}		return settingsObject;}function getSettingsFromSoltion(sol) {	var str,		file,		stream,		returnObject,		settingsObject;		returnObject = {};	try {		file = sol.getSettingFile("database");				stream = TextStream(file, "read");		str = stream.read();				settingsObject = JSON.parse(XmlToJSON(str, "json-bag", "settings"));				returnObject = {};				if(settingsObject.hasOwnProperty("database") && settingsObject.database.length > 0) {						returnObject.database = settingsObject.database[0];		} else {						returnObject.database = {};		}				returnObject.solution = {};		if(settingsObject.solution[0].hasOwnProperty("directory") && settingsObject.solution[0].directory.length > 0) {						returnObject.solution.directory = settingsObject.solution[0].directory[0];		} else {						returnObject.solution.directory = {};		}				if(settingsObject.solution[0].hasOwnProperty("serverStartup") && settingsObject.solution[0].serverStartup.length > 0) {						returnObject.solution.serverStartup = settingsObject.solution[0].serverStartup[0];		} else {						returnObject.solution.directory = {};		}			} catch(e) {		console.log("Error reading solution settings files", e);	}		return returnObject;}/** * TODO define open permission for this methods
 */// exports.checkAdminAccess = function check_admin_access() {
// 
	// var result;
// 	
	// result = {
		// access : false,
		// status : ""
	// };
// 	
	// if(directory.currentUser() !== null) {
// 		
		// if(directory.currentUserBelongsTo("01000000000000000000000000000000")) {
// 			
			// result.access = true;
		// } else {
// 			
			// directory.logout();
			// result.status = "accessDenied";
		// }
	// }
// 	
	// return result;
// }