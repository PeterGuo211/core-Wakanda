/** * Return the test symbol table name without extension *  * @return {String} */function getTestSymbolTableName(){	return "TestSymbolTable";}/** * Return the test symbol table filename *  * @return {String} */function getTestSymbolTableFilename(){	return getTestSymbolTableName() + ".waSym";}/** * Return the test symbol table path *  * @return {String} */function getTestSymbolTablePath(){	return getProjectPath() + getTestSymbolTableFilename();}/** * Return the test file path  */function getTestFilePath(){	return getProjectPath() + "TestFiles/test_01.js";}/** * Return the project path *  * @return {String} */function getProjectPath(){	return application.getFolder("path");}/** * Return the JavaScript Support Files folder path *  * @return {String} */function getJSFFolderPath(){	return getProjectPath() + "JSF/";}/** * Return the Definitions folder path *  * @return {String} */function getDefinitionsFolderPath(){	return getProjectPath() + "Definitions/";}/** * Clean and rebuild test symbol table */function init(){	makeClean();	buildTestSymbolTable();}/** * Clean project */ function makeClean(){	removeTestSymbolTable();}/** * Remove symbol table files (with "waSym", "waSymData", "Match" * extension) *  * @param {String} symTableName : name of the symbol table */function removeTestSymbolTable(symTableName){	var symTableExtensions = [ "waSym", "waSymData", "Match" ];	symTableExtensions.forEach( 		function(fileExtension) {				var file = File(getProjectPath() + getTestSymbolTableName() + "." + fileExtension);				if (file.exists)					file.remove();		}	);}/** * Build test symbol table */function buildTestSymbolTable(){		buildJSFSymbolTable();	buildDefinitionsSymbolTable();	buildTestFilesSymbolTable();}/** * Fill test symbol table with JSF files */function buildJSFSymbolTable(){	var jsfFolder = getJSFFolderPath();	var jsfSubFolders = [ 	{ name: "bothSides", mode: "both" },	{ name: "serverSide", mode: "server" },	{ name: "clientSide", mode: "client" } ];	for (var i = 0; i < jsfSubFolders.length; i++) {		var folder = jsfFolder + jsfSubFolders[i].name + "/";		var orderFile = File(folder + "order.txt");				// order mode		if ( orderFile.exists ) {			var files = orderFile.toString().split("\r\n");			for (var j = 0; j < files.length; j++)  {				if ( files[j].length ) {					var file = File( folder + files[j] );		  			if ( file.exists )		  				parseFile( getTestSymbolTablePath(), file,  jsfSubFolders[i].mode );				}		  	}		}		else {			var folder = Folder( getJSFFolderPath() +  jsfSubFolders[i].name );			folder.forEachFile( function(file)  { parseFile( getTestSymbolTablePath(), file, jsfSubFolders[i].mode ); } );				}	}	}/** * @param {Folder} folder */function parseJSFFolder(folder) {	}/** * Fill test symbol table with Definitions files */function buildDefinitionsSymbolTable(){	var bothSidesFolder  = Folder( getDefinitionsFolderPath() + "bothSides");	var clientSideFolder = Folder( getDefinitionsFolderPath() + "clientSide");	var serverSideFolder = Folder( getDefinitionsFolderPath() + "serverSide");		bothSidesFolder.forEachFile( function(file)  { parseFile( getTestSymbolTablePath(), file, "both"); } );	clientSideFolder.forEachFile( function(file) { parseFile( getTestSymbolTablePath(), file, "client"); } );	serverSideFolder.forEachFile( function(file) { parseFile( getTestSymbolTablePath(), file, "server"); } );	}/** * Fill test symbol table with "TestFiles" directory content */function buildTestFilesSymbolTable(){	var testFiles = Folder(getProjectPath() + "TestFiles");	testFiles.forEachFile( function(file) { parseFile( getTestSymbolTablePath(), file, "both"); } );}/** * Parse file using SSJS test API *  * @param {String} symTable : input value to complete * @param {String} filePath : file where to test complation * @param {String} context  : context of the parsed file : Must be "client", "server" or "both" * @return {Boolean} */function parseFile(symTable, file, context){	if (file.exists)		return _syntaxTester.parseFile( symTable, file.path, "project", context); 	return false;	}/** * Get completion values using SSJS test API *  * @param {String} input : input value to complete * @param {String} file  : file where to test completion * @param {String} line  : line where to test completion * @param {String} input : completion mode. Must be "text" or "displayText" * @return {Array} */function getCompletions(input, file, line, mode){   var result = new Array();   var completions = _syntaxTester.getCompletions(getTestSymbolTablePath(), input, getProjectPath() + file, line, mode);   for (var i = 0; i < completions.getResultCount(); i++)   	result.push(completions.getResult(i));   return result;}/** * Get symbol using SSJS test API *  * @param {String} name : name of the symbol * @param {String} file  : file where the symbol is defined * @return {Object} */function getSymbol(name, file, line){	return  _syntaxTester.getSymbol(getTestSymbolTablePath(), name, getDefinitionsFolderPath() + file, line);}/** * Get symbol definition using SSJS test API *  * @param {String} name : name of the symbol * @param {String} file  : file where the symbol is defined * @return {Object} */function gotoDefinition(selection, file, line){	return  _syntaxTester.gotoDefinition(getTestSymbolTablePath(), getDefinitionsFolderPath() + file, line, selection);}/** * Tokenize a JavaScript source using SSJS test API *  * @param {String} str : string to tokenize * @param {String} extension : language extension ("js" for JavaScript) * @return {Array} of tokens types */function tokenize(str, extension) {	return _syntaxTester.tokenize(str, extension);}/** * Generate tests cases: test methods to YUI test cases object *  * @param {Object} tests: object containing tests description * @param {Object} testCase: YUI test cases object to fill */function generateTestCases(tests, testCase) {	for (var test in tests.list) {		var prop = "" + test;		testCase[prop] = new Function("check" + tests.type + "Result(\"" + prop + "\");");		testCase["_should"]["ignore"][prop] = (tests.list[prop]["ignore"] == undefined) ? false : tests.list[prop]["ignore"];	}		}/** * Check unit test on symbol *  * @param {String} test: name of the test in global "tests" object */function checkDeclarationResult(test) {	var result = getSymbol(tests.list[test]["name"], tests.list[test]["file"], tests.list[test]["line"]);			Y.Assert.areNotEqual(result, undefined);	for (var i = 0; i < tests.props.length; i++) {		var key = tests.props[i];		Y.Assert.areEqual(tests.list[test][key], result[key], "Symbol " + key + " should be: " + tests.list[test][key]);	}}/** * Check unit test on token *  * @param {String} test: name of the test in global "tests" object */function checkTokenizationResult(test) {	var result = tokenize(tests.list[test]["source"], "js");	var expected = tests.list[test]["tokens"];	Y.Assert.areNotEqual(result, undefined);	Y.ArrayAssert.itemsAreSimilar(expected, result, true, "Array should be similar. Expected: [" + expected.toString() + "] Actual: ["  + result.toString() + "]");}/** * Check completion unit test  *  * @param {String} test: name of the test in global "tests" object */function checkCompletionResult(test) {		var result = getCompletions(tests.list[test]["source"], tests.list[test]["file"], tests.list[test]["line"], tests.list[test]["mode"]);	var expected = tests.list[test]["results"];	Y.Assert.areNotEqual(result, undefined);	Y.ArrayAssert.itemsAreSimilar(expected, result, true, "Array should be similar. Expected: [" + expected.toString() + "] Actual: ["  + result.toString() + "]");}/** * Check unit test on token *  * @param {String} test: name of the test in global "tests" object */function checkGotoDefinitionResult(test) {	 	 var results = gotoDefinition(tests.list[test]["selection"], tests.list[test]["file"], tests.list[test]["line"]);	 	 Y.Assert.areEqual(tests.list[test].results.length, results.getResultCount(), "Unexpected number of result(s)");	 	 for (var i = 0; i < results.getResultCount(); i++) {		var result = results.getResult(i);		var expectedName = tests.list[test].results[i]["name"];		var expectedFile = tests.list[test].results[i]["file"];		var expectedLine = tests.list[test].results[i]["line"];		var actualName = result["name"];		var actualFile = result["file"];		var actualLine = result["line"];		Y.Assert.areEqual(expectedName, actualName, "Name is incorrect.");		Y.Assert.areEqual(expectedFile, actualFile, "File is incorrect.");		Y.Assert.areEqual(expectedLine, actualLine, "Line number is incorrect.");	 }}